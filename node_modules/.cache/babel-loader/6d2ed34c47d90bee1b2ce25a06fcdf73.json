{"remainingRequest":"C:\\Users\\Administrator\\Documents\\HBuilderProjects\\bilibili-app\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\Administrator\\Documents\\HBuilderProjects\\bilibili-app\\src\\main.js","dependencies":[{"path":"C:\\Users\\Administrator\\Documents\\HBuilderProjects\\bilibili-app\\src\\main.js","mtime":1620828989390},{"path":"C:\\Users\\Administrator\\Documents\\HBuilderProjects\\bilibili-app\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1620825916725},{"path":"C:\\Users\\Administrator\\Documents\\HBuilderProjects\\bilibili-app\\node_modules\\babel-loader\\lib\\index.js","mtime":1620825916511}],"contextDependencies":[],"result":["import \"regenerator-runtime/runtime\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\Administrator\\\\Documents\\\\HBuilderProjects\\\\bilibili-app\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/asyncToGenerator\";\nimport \"C:\\\\Users\\\\Administrator\\\\Documents\\\\HBuilderProjects\\\\bilibili-app\\\\node_modules\\\\core-js\\\\modules\\\\es6.array.iterator.js\";\nimport \"C:\\\\Users\\\\Administrator\\\\Documents\\\\HBuilderProjects\\\\bilibili-app\\\\node_modules\\\\core-js\\\\modules\\\\es6.promise.js\";\nimport \"C:\\\\Users\\\\Administrator\\\\Documents\\\\HBuilderProjects\\\\bilibili-app\\\\node_modules\\\\core-js\\\\modules\\\\es6.object.assign.js\";\nimport \"C:\\\\Users\\\\Administrator\\\\Documents\\\\HBuilderProjects\\\\bilibili-app\\\\node_modules\\\\core-js\\\\modules\\\\es7.promise.finally.js\";\nimport Vue from 'vue';\nimport App from \"./App.vue\";\nimport channel from \"./services/channel.js\";\nVue.config.productionTip = false; //var categories = channel.getChannels(); 、\n//这里得到Promise {<pending>} 这样一个对象 原因是因为getChannels方法是异步方法 \n//所以应该用 async 来封装成一个异步函数\n\nfunction asyncGetChannels() {\n  return _asyncGetChannels.apply(this, arguments);\n} //调用封装的异步函数\n//asyncGetChannels();\n\n\nfunction _asyncGetChannels() {\n  _asyncGetChannels = _asyncToGenerator(\n  /*#__PURE__*/\n  regeneratorRuntime.mark(function _callee() {\n    var categories;\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return channel.getChannels();\n\n          case 2:\n            categories = _context.sent;\n            console.log(categories);\n            return _context.abrupt(\"return\", categories);\n\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _asyncGetChannels.apply(this, arguments);\n}\n\nnew Vue({\n  render: function render(h) {\n    return h(App);\n  }\n}).$mount('#app');",{"version":3,"sources":["C:\\Users\\Administrator\\Documents\\HBuilderProjects\\bilibili-app\\src\\main.js"],"names":["Vue","App","channel","config","productionTip","asyncGetChannels","getChannels","categories","console","log","render","h","$mount"],"mappings":";;;;;;AAAA,OAAOA,GAAP,MAAgB,KAAhB;AACA,OAAOC,GAAP;AACA,OAAOC,OAAP;AAEAF,GAAG,CAACG,MAAJ,CAAWC,aAAX,GAA2B,KAA3B,C,CACA;AACA;AACA;;SACeC,gB;;EAMf;AACA;;;;;;0BAPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAEwBH,OAAO,CAACI,WAAR,EAFxB;;AAAA;AAEKC,YAAAA,UAFL;AAGCC,YAAAA,OAAO,CAACC,GAAR,CAAYF,UAAZ;AAHD,6CAIQA,UAJR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AASA,IAAIP,GAAJ,CAAQ;AACNU,EAAAA,MAAM,EAAE,gBAAAC,CAAC;AAAA,WAAIA,CAAC,CAACV,GAAD,CAAL;AAAA;AADH,CAAR,EAEGW,MAFH,CAEU,MAFV","sourcesContent":["import Vue from 'vue'\r\nimport App from './App.vue'\r\nimport channel from \"./services/channel.js\"\r\n\r\nVue.config.productionTip = false\r\n//var categories = channel.getChannels(); 、\r\n//这里得到Promise {<pending>} 这样一个对象 原因是因为getChannels方法是异步方法 \r\n//所以应该用 async 来封装成一个异步函数\r\nasync function asyncGetChannels(){\r\n\t//这就是封装的异步函数 需要使用await\r\n\tvar categories = await channel.getChannels(); \r\n\tconsole.log(categories)\r\n\treturn categories\r\n}\r\n//调用封装的异步函数\r\n//asyncGetChannels();\r\n\r\nnew Vue({\r\n  render: h => h(App),\r\n}).$mount('#app')\r\n"]}]}